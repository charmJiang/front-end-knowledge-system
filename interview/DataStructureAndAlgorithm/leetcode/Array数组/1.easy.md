[TOC]



#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```



```javascript
// Using ES6 data structure Map. Time complexity is O(n).
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let map = new Map();
    
    for(let i = 0; i < nums.length; i ++) {
        if(map.has(target - nums[i])) {
            return [map.get(target - nums[i]), i];
        } else {
            map.set(nums[i], i);
        }
    }
	return [];
};

// Using Object. Time complexity is also O(n)
var twoSum = function(nums, target) {
	let hash = {};
	
	for(let i = 0; i < nums.length; i++) {
		const n = nums[i];
		if(hash[target - n] !== undefined) {
			return [hash[target - n], i];
		}
		hash[n] = i;
	}
	return [];
}
```



#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

给定一个已按照 **升序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

 

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```



##### 题解1：双指针【最佳】

```javascript
const twoSum = (numbers, target) => {
    let p1 = 0
    let p2 = numbers.length - 1
    
    while (numbers[p1] + numbers[p2] !== target) {
        if (numbers[p1] + numbers[p2] > target) {
            p2--
        } else {
            p1++
        }
    }
    
    return [p1 + 1, p2 + 1]
}
```

##### 题解2:二分查找

```javascript
var twoSum=function(numbers,target){
    for(let i=0;i<numbers.length;i++){
        let other=target-numbers[i]
        let res=binarySearch(numbers,other)
        if(res!=-1&&i!=res){
            return i<res?[i+1,res+1]:[res+1,i+1]
        }
    }
    return []
}
const binarySearch = function(numbers, target) {
    let high=numbers.length
    let low=0
    while(low<=high){
        let mid=parseInt((low+high)/2)
        if(numbers[mid]===target){
           return mid
        }else if(numbers[mid]<target){
            low=mid+1
        }else{
            high=mid-1
        }
    }
    return -1
};
```



#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```



题解:

- 创建一个慢指针 i，指向数组第一位数字，再创建一个快指针 j，指向数组第二位。
- 若 nums[j]和 nums[i] 不等，则先将 ii 递增 11，然后把 nums[i] 改为 nums[j]。
- 因为最初 i 等于 0 时的数字未统计，所以最终返回结果需要 +1。



```javascript
var removeDuplicates = function(nums) {
    if(!nums.length) return 0;
    let i = 0;
    for(let j = 1; j < nums.length; j++){
        if(nums[j] !== nums[i]){
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}

// 2
var removeDuplicates = function(nums) {
    let i = 0;
    for (let j = 0; j < nums.length; j++) {
        if (nums[j] != nums[i]) 
            nums[++i] = nums[j];
    }
    return ++i;
};
```



#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```



题解1:

标签：拷贝覆盖

- 主要思路是遍历数组 nums，每次取出的数字变量为 num，同时设置一个下标 ans
- 在遍历过程中如果出现数字与需要移除的值不相同时，则进行拷贝覆盖 nums[ans] = num，ans 自增 1
- 如果相同的时候，则跳过该数字不进行拷贝覆盖，最后 ans 即为新的数组长度
- 这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可
- 时间复杂度：O(n)，空间复杂度：O(1)

```javascript
var removeElement = function(nums, val) {
    let ans = 0;
    for(const num of nums) {
        if(num != val) {
            nums[ans] = num;
            ans++;
        }
    }
    return ans;
};

```

题解2:

- 标签：交换移除
- 主要思路是遍历数组 nums，遍历指针为 i，总长度为 ans
- 在遍历过程中如果出现数字与需要移除的值不相同时，则i自增1，继续下一次遍历
- 如果相同的时候，则将 nums[i]与nums[ans-1] 交换，即当前数字和数组最后一个数字进行交换，交换后就少了一个元素，故而 ans 自减 1
- 这种思路在移除元素较少时更适合使用，最极端的情况是没有元素需要移除，遍历一遍结束即可
- 时间复杂度：O(n)，空间复杂度：O(1)

```javascript
var removeElement = function(nums, val) {
    let ans = nums.length;
    for (let i = 0; i < ans;) {
        if (nums[i] == val) {
            nums[i] = nums[ans - 1];
            ans--;
        } else {
            i++;
        }
    }
    return ans;
};

```



题解3：

Many people posting solutions which simply modifying fake length counter but their functions aren’t modifying array correctly (you can test many of them by returning array instead of pseudo-length). This solution correctly modifies given array (but still weird that you need to return length).

```javascript
const removeElement = (nums, val) => {
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === val) {
      nums.splice(i, 1);
      i--;
    }
  }
  return nums.length;
};
```



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```



[leetcode官方视频题解](https://leetcode-cn.com/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/)

##### 题解1:二分查找

- 如果该题目暴力解决的话需要 O(n)O(n) 的时间复杂度，但是如果二分的话则可以降低到 O(logn)O(logn) 的时间复杂度
- 整体思路和普通的二分查找几乎没有区别，先设定左侧下标 left 和右侧下标 right，再计算中间下标 mid
- 每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] < target 则 left 右移，nums[mid] > target 则 right 左移
- 查找结束如果没有相等值则返回 left，该值为插入位置
  时间复杂度：O(logn)O(logn)
- 二分查找的思路不难理解，但是边界条件容易出错，比如 循环结束条件中 left 和 right 的关系，更新 left 和 right 位置时要不要加 1 减 1。

```javascript
var searchInsert = function(nums, target) {
    const n = nums.length;
    let left = 0, right = n - 1, ans = n;
    while (left <= right) {
        let mid = ((right - left) >> 1) + left;
        if (target <= nums[mid]) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
};

```

- 时间复杂度：O(logn)，其中 nn 为数组的长度。二分查找所需的时间复杂度为 O(\log n)O(logn)。

- 空间复杂度：O(1)O(1)。我们只需要常数空间存放若干变量。

##### 题解2：暴力求解

- 数组是排好序的，我们希望找到第一个大于等于 target 的元素，它的位置就是 target 希望插入的位置。
- 如果数组元素都比 target 小，则 target 应该插在数组的末尾

```javascript
const searchInsert = (nums, target) => {
  for (let i = 0; i < nums.length; i++) {
    if (target <= nums[i]) {
      return i;
    }
  }
  return nums.length; 
};

```



#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 **示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

 

题解1:

- 这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来
- 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
- 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
- 如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
- 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果
- 时间复杂度：O(n)

[图片讲解](https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/)

[leetcode](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)

```javascript
var maxSubArray = function(nums) {
    let ans = nums[0];
    let sum = 0;
    for(const num of nums) {
        if(sum > 0) {
            sum += num;
        } else {
            sum = num;
        }
        ans = Math.max(ans, sum);
    }
    return ans;
};

```



#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```

 

```javascript
var plusOne = function(digits) {
    for(var i = digits.length - 1; i >= 0; i--){
         digits[i]++; 
        if(digits[i] > 9){
            digits[i] = 0;
        }else{
            return digits;
        }
    }
    digits.unshift(1);
    return digits;
};
```



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

##### 方法一：直接合并后排序

最直观的方法是先将数组 nums2放进数组nums1的尾部，然后直接对整个数组进行排序。

```javascript
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m, ...nums2);
    nums1.sort((a, b) => a - b);
};
```

复杂度分析

- 时间复杂度：O((m+n)log(m+n))。
- 排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)log(m+n))。

空间复杂度：O(log(m+n))。

- 排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为O(log(m+n))。

##### 方法二：双指针

方法一没有利用数组num1与nums2
	已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示：

![gif1](https://assets.leetcode-cn.com/solution-static/88/1.gif)

```javascript

var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    const sorted = new Array(m + n).fill(0);
    var cur;
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            cur = nums2[p2++];
        } else if (p2 === n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (let i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
};

```

复杂度分析

- 时间复杂度：O(m+n)
- 指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)
- 空间复杂度：O(m+n)
- 需要建立长度为 m+n 的中间数组 sorted。

#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

![](https://gitee.com/vr2/images/raw/master/images/cssjyH.png)

```javascript
var generate = function(numRows) {
    const ret = [];

    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1).fill(1);
        for (let j = 1; j < row.length - 1; j++) {
            row[j] = ret[i - 1][j - 1] + ret[i - 1][j];
        }
        ret.push(row);
    }
    return ret;
};
```



**复杂度分析**

- 时间复杂度：O*(*numRows^2)。
- 空间复杂度：O(1)。不考虑返回值的空间占用。



#### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 3
输出: [1,3,3,1]
```

**进阶：**

你可以优化你的算法到 *O*(*k*) 空间复杂度吗？

##### 方法一：递推

![bEf0Xv](https://gitee.com/vr2/images/raw/master/images/bEf0Xv.png)

```javascript
var getRow = function(rowIndex) {
    const C = new Array(rowIndex + 1).fill(0);
    for (let i = 0; i <= rowIndex; ++i) {
        C[i] = new Array(i + 1).fill(0);
        C[i][0] = C[i][i] = 1;
        for (let j = 1; j < i; j++) {
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
        }
    }
    return C[rowIndex];
};
```

**优化**

注意到对第 i+1行的计算仅用到了第 i*i* 行的数据，因此可以使用**滚动数组**的思想优化空间复杂度。

```javascript
var getRow = function(rowIndex) {
    let pre = [], cur = [];
    for (let i = 0; i <= rowIndex; ++i) {
        cur = new Array(i + 1).fill(0);
        cur[0] = cur[i] =1;
        for (let j = 1; j < i; ++j) {
            cur[j] = pre[j - 1] + pre[j];
        }
        pre = cur;
    }
    return pre;
};
```

**进一步优化**

![eZCDFr](https://gitee.com/vr2/images/raw/master/images/eZCDFr.png)

```javascript
var getRow = function(rowIndex) {
    const row = new Array(rowIndex + 1).fill(0);
    row[0] = 1;
    for (let i = 1; i <= rowIndex; ++i) {
        for (let j = i; j > 0; --j) {
            row[j] += row[j - 1];
        }
    }
    return row;
};
```

复杂度分析

时间复杂度:O(rowIndex^2 )。

空间复杂度：O(1)。不考虑返回值的空间占用。

##### 方法二：线性递推

![0vBhQu](https://gitee.com/vr2/images/raw/master/images/0vBhQu.png)

```javascript
var getRow = function(rowIndex) {
    const row = new Array(rowIndex + 1).fill(0);
    row[0] = 1;
    for (let i = 1; i <= rowIndex; ++i) {
        row[i] = row[i - 1] * (rowIndex - i + 1) / i;
    }
    return row;
};
```

**复杂度分析**

- 时间复杂度：O*(*rowIndex)。
- 空间复杂度：*O*(1)。不考虑返回值的空间占用。



#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```



##### 题解1:暴力方法

- 双层遍历 O(n^2) 
- a 外层遍历i 0~prices.length - 1
- b 内层遍历j i + 1~prices.length - 1
- c 找出大于当前项目 prices[i] 并 卖出 并 更新最大值
- d 输出结果



```javascript
var maxProfit = function(prices) {
   if (!prices || !prices.length) return 0

    const len = prices.length
    let max = 0, cur = 0, next = 0

    for (let i = 0; i < len; i++) {
        cur = prices[i]
        for (let j = i + 1; j < len; j++) {
            next = prices[j]
            if (next > cur) {
                max = Math.max(max, next - cur)
            }
        }
    }

    return max
}
```



##### 题解2: 动态规划 DP  Time: O(n) + Space: O(n)

```javascript
思路二 DP  Time: O(n) + Space: O(n)
        dp[i] 前i天卖出的最大利润
        min : prices 前i项中的最小值
        prices[i] - min: 当前位置卖出可得最大利润
        dp[i - 1] : 前i-1项目卖出可得的最大利润
        [7, 1, 5, 3, 6, 4] => dp[i] = Math.max( dp[i - 1], prices[i] - min )
        [7]                [0, 0, 0, 0, 0, 0]
        [7, 1]             [0, 0, 0, 0, 0, 0]
        [7, 1, 5]          [0, 0, 4, 0, 0, 0]
        [7, 1, 5, 3]       [0, 0, 4, 4, 0, 0]
        [7, 1, 5, 3, 6]    [0, 0, 4, 4, 5, 0]
        [7, 1, 5, 3, 6, 4] [0, 0, 4, 4, 5, 5]

        输出结果 dp[len - 1]

var maxProfit = function(prices) {
  	if (!prices || !prices.length) return 0

    const len = prices.length, dp = new Array(len).fill(0)
    let min = prices[0] // 前i项的最小值

    for (let i = 1, price; i < len; i++) {
        price = prices[i]
        min = Math.min(min, price)
        dp[i] = Math.max(dp[i - 1], price - min )
    }

    return dp[len - 1]
}
```



##### 题解3: DP + 常量级变量 

-  DP + 常量级变量 min max Time - O(n) + Space - O(1)
- 精简 我们只关心 max 与 min 故不需要再构建dp 数组

动态规划（Dynamic Programming，DP）是一种将复杂问题分解成小问题求解的策略，但与分治算法不同的是，分治算法要求各子问题是相互独立的，而动态规划各子问题是相互关联的。

> 分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。

我们使用动态规划求解问题时，需要遵循以下几个重要步骤：

- 定义子问题
- 实现需要反复执行解决的子子问题部分
- 识别并求解出边界条件

##### 第一步：定义子问题

动态规划是将整个数组归纳考虑，假设我们已经知道了 i-1 个股票的最大利润为 dp[i-1]，显然 i 个连续股票的最大利润为 dp[i-1] ，要么就是就是 prices[i] - minprice （ minprice 为前 i-1 支股票的最小值 ），在这两个数中我们取最大值

##### 第二步：实现需要反复执行解决的子子问题部分

```javascript
dp[i] = Math.max(dp[i−1], prices[i] - minprice)
```

##### 第三步：识别并求解出边界条件

```javascript
dp[0]=0
```

**最后一步：把尾码翻译成代码，处理一些边界情况**

因为我们在计算 dp[i] 的时候，只关心 dp[i-1] 与 prices[i]，因此不用把整个 dp 数组保存下来，只需设置一个 max 保存 dp[i-1] 就好了。

**代码实现（优化）：**

```javascript
let maxProfit = function(prices) {
    let max = 0, minprice = prices[0]
    for(let i = 1; i < prices.length; i++) {
        minprice = Math.min(prices[i], minprice)
        max = Math.max(max, prices[i] - minprice)
    }
    return max
}
```

##### 复杂度分析：

- 时间复杂度：O(n)
- 空间复杂度：O(1)

```javascript
var maxProfit = function(prices) {
  	if (!prices || !prices.length) return 0

    let min = Number.MAX_SAFE_INTEGER, max = 0

    for (let i = 0, price; i < prices.length; i++) {
        price = prices[i]
        min = Math.min(min, price)
        max = Math.max(max, price - min)
    }

    return max
} 


```

##### 题解4: 极简版 一行代码 （[参看我的打家劫舍题解](https://leetcode-cn.com/problems/house-robber/solution/wu-chong-fang-shi-you-fan-ru-jian-you-ya-shi-xian-/)）

```javascript
var maxProfit = function(prices) {
    /* 
        思路四 极简版 一行代码 巧用reduce + [min, max] 本质上是思路三的一种简写方法 
        虽然 只有一行代码 但是 可读性 与 推展性 不高 生产环境的话还是推荐 思路三
        prices.reduce((p, v) => [
            Math.min(p[0], v), // 更新最小值 
            Math.max(p[1], v - p[0] ) // 更新最大值
        ], [Number.MAX_SAFE_INTEGER, 0])[1]
    */
    return prices.reduce((p, v) => [Math.min(p[0], v), Math.max(p[1], v - p[0]) ], [Number.MAX_SAFE_INTEGER, 0])[1]
}
```



#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

##### 解法一：峰底买入，峰顶卖出

![yZxYix](https://gitee.com/vr2/images/raw/master/images/yZxYix.png)

如图，在第二天买入，第三天卖出，第四天买入，第五天卖出获利最高，此处代码不再赘述，可以自己尝试写一下

##### 解法二：贪心算法

贪心算法，故名思义，总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择。

某种意义上说，贪心算法是很贪婪、很目光短浅的，它不从整体考虑，仅仅只关注当前的最大利益，所以说它做出的选择仅仅是某种意义上的局部最优，但是贪心算法在很多问题上还是能够拿到最优解或较优解，所以它的存在还是有意义的。

对应于该题，第一天买入，第二天卖出，…，第 i 天买入，第 i+1 天卖出，如果 i 天买入第 i+1 天卖出有利润则买入，否则不买

第 i-1 天买入第 i 天卖出获利 prices[i+1]-prices[i] ，我们仅仅需要将 prices[i+1]-prices[i] 的所有正值加起来就是可获取的最大利益

代码实现：

```javascript
let maxProfit = function(prices) {
    let profit = 0
    for (let i = 0; i < prices.length - 1; i++) {
        if (prices[i + 1] > prices[i]) {
            profit += prices[i + 1] - prices[i]
        }
    }
    return profit
}
```

复杂度分析：

- 时间复杂度：O(n)
- 空间复杂度：O(1)

#### [买卖股票最佳时机6道题解](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-zui-jia-shi-ji-6dao-ti-jie-by-xi-6/)

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```



##### [题解1 leetcode官方](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/)

```javascript
var maxProfit = function(prices) {
    const n = prices.length;
    let buy1 = -prices[0], buy2 = -prices[0];
    let sell1 = 0, sell2 = 0;
    for (let i = 1; i < n; i++) {
        buy1 = Math.max(buy1, -prices[i]);
        sell1 = Math.max(sell1, buy1 + prices[i]);
        buy2 = Math.max(buy2, sell1 - prices[i]);
        sell2 = Math.max(sell2, buy2 + prices[i]);
    }
    return sell2;
};
```

**复杂度分析**

- 时间复杂度：O(n)*O*(*n*)，其中 n*n* 是数组 \textit{prices}*prices* 的长度。
- 空间复杂度：O(1)*O*(1)。



2种方式3种数据结构递归，3种方式动态规划，尝试二分和贪心算法。替换Math.max完成更优解

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/di-gui-dong-tai-gui-hua-tan-xin-er-fen-4-xxd5

##### 题解一 贪心

将股票价格区间，分成第1次和第2次交易两个区域。本题示例1`[3,3,5,0,0,3,1,4]`如图

![DeywFI](https://gitee.com/vr2/images/raw/master/images/DeywFI.png)

贪心策略：最低点买入，最高点卖出，利润最大
第1次交易：初始第0天买入，从第1天顺序遍历，第i天价格比上次买入：

- `低`，重新在当天买入。即 更新最小值
- `高`，假设在当天卖出，利润 存入dp0[i]
  - 遍历结束，第1次交易在第[0, 数组长度 - 1]天结束时的利润dp0

第2次交易：初始最后1天卖出，从倒数第2天倒序遍历，第i天价格比上次卖出：

- 高，重新在当天卖出。即 更新最大值

  低，假设在当天买入，上次（最大值所在那天）卖出，利润 dp1

  - 第2次交易，最早只能在第2天开始，第3天产生利润

2次交易的利润和 = 第i天作为第1次交易结束dp0[i] + 第i天以后进行第2次交易利润dp1

```javascript
var maxProfit = function(prices) {
    let n = prices.length, i = 0, min = prices[0], max = prices[n - 1], dp0 = Array(n), dp1 = 0, r = 0, t
    while (++i < n) (t = prices[i] - min) < 0 ? min = prices[i] : dp0[i] = t
    while (i-- > 1) {
         (t = max - prices[i]) < 0 ? max = prices[i] : t > dp1 && (dp1 = t)
        ;(t = dp0[i] + dp1) > r && (r = t) // ][ 或 )( 相邻，分号不能省略
    }
    return r
};
```



##### 题解二 递归

JS递归超过一定次数（不同浏览器不同）仍未到达边界会发生栈溢出错误

###### 2.1 计数

- 状态s：有股票true，无股票false。统计卖出次数j，卖出时j + 1
- 分支：什么都不做 或 有股票卖出 或 无股票买入
- 边界：卖出次数达到2次 或 数组越界

```javascript
var maxProfit = function(prices) {
    d = (i, j, s) => j === 2 || i === prices.length ? 0 : 
                    Math.max(d(i + 1, j, s), 
                    s ? d(i + 1, j + 1, false) + prices[i] : d(i + 1, j, true) - prices[i])
    return d(0, 0, false)
};
```

201 / 214 个通过测试用例

**剪枝**
递归函数变换形参i j s为键名，构造缓存函数。递归到底回溯时，遇相同键名直接返回结果
多变量生成整数键名：前 * 后的范围 + 后

- s是布尔值，j与s组合：`j * 2 + s`
- j是交易次数`<2`，`*2`后`<4`，与i组合：`i * 4 + j * 2 + s`



```javascript
// Array
var maxProfit = function(prices) {
    let h = [], t
    d = (i, j, s) => j === 2 || i === prices.length ? 0 : 
                     h[t = i * 4 + j * 2 + s] !== void 0 ? h[t] : h[t] =  
                     Math.max(d(i + 1, j, s), 
                     s ? d(i + 1, j + 1, 0) + prices[i] : d(i + 1, j, 1) - prices[i])
    return d(0, 0, 0)
};

// Object
var maxProfit = function(prices) {
    let h = Object.create(null), t
    d = (i, j, s) => j === 2 || i === prices.length ? 0 : 
                     h[t = i * 4 + j * 2 + s] !== void 0 ? h[t] : h[t] =  
                     Math.max(d(i + 1, j, s), 
                     s ? d(i + 1, j + 1, 0) + prices[i] : d(i + 1, j, 1) - prices[i])
    return d(0, 0, 0)
};

// Map
var maxProfit = function(prices) {
    let h = new Map, t, t1
    d = (i, j, s) => j === 2 || i === prices.length ? 0 : 
                     h.has(t = i * 4 + j * 2 + s) ? h.get(t) : (h.set(t, t1 =  
                     Math.max(d(i + 1, j, s), 
                     s ? d(i + 1, j + 1, 0) + prices[i] : d(i + 1, j, 1) - prices[i])), t1)
    return d(0, 0, 0)
};
```




###### 2.2 状态

状态s：偶数为有股票，奇数为无股票。状态转移：s + 1

- 0第1次交易前有股票，1第1次交易后无股票

2第2次交易前有股票，3第2次交易后无股票
...
分支：什么都不做 或 奇数无股票买入 或 偶数有股票卖出
边界：第2次交易后，进入第3次交易，即状态s = 4 或 数组越界

```javascript
var maxProfit = function(prices) {
    d = (i, s) => s === 4 || i === prices.length ? 0 : 
                  Math.max(d(i + 1, s), 
                  s & 1 ? d(i + 1, s + 1) + prices[i] : d(i + 1, s + 1) - prices[i])
    return d(0, 0, 0)
};
```

**剪枝**
递归函数变化形参`i ` `s`，`s`范围为`[0, 3]`，键名：`i * 4 + s`

```javascript
// Array
var maxProfit = function(prices) {
    let h = [], t
    d = (i, s) => s === 4 || i === prices.length ? 0 : h[t = i * 4 + s] !== void 0 ? h[t] : h[t] = 
                  Math.max(d(i + 1, s, h), 
                  s & 1 ? d(i + 1, s + 1, h) + prices[i] : d(i + 1, s + 1, h) - prices[i])
    return d(0, 0, h)
};

// Object
var maxProfit = function(prices) {
    let h = Object.create(null), t
    d = (i, s) => s === 4 || i === prices.length ? 0 : h[t = i * 4 + s] !== void 0 ? h[t] : h[t] = 
                  Math.max(d(i + 1, s, h), 
                  s & 1 ? d(i + 1, s + 1, h) + prices[i] : d(i + 1, s + 1, h) - prices[i])
    return d(0, 0, h)
};

// Map
var maxProfit = function(prices) {
    let h = new Map, t, t1
    d = (i, s) => s === 4 || i === prices.length ? 0 : h.has(t = i * 4 + s) ? h.get(t) : (h.set(t, t1 = 
                  Math.max(d(i + 1, s, h), 
                  s & 1 ? d(i + 1, s + 1, h) + prices[i] : d(i + 1, s + 1, h) - prices[i])), t1)
    return d(0, 0, h)
};
```




##### 三 动态规划

###### 3.1 数组

dp[i]表示第i / 2取整次交易。i为奇数，交易前，i为偶数，交易后。与递归状态相同

- dp[0]第1次交易前 分支：什么都不做 或 买入 → 第1次交易后
- dp[1]第1次交易后 分支：什么都不做 或 卖出 → 第2次交易前
- dp[2]第2次交易前 分支：什么都不做 或 买入 → 第2次交易后
- dp[3]第2次交易后 分支：什么都不做 或 卖出 → 第3次交易前

特殊情况：没有 或 只有1次交易：

- 第1次交易前 dp[1] = 0，即 dp[3] = dp[1]，返回dp[3]
- 第1次交易后 dp[1]有值，-prices[i]取大又+prices[i]取大，还是=dp[1]，返回dp[3]

```javascript
var maxProfit = function(prices) {
    const dp = new Int32Array(4)
    dp[0] = dp[2] = -prices[0]
    for (let i = 1; i < prices.length; i++) {
        dp[0] = Math.max(dp[0],       - prices[i])
        dp[1] = Math.max(dp[1], dp[0] + prices[i])
        dp[2] = Math.max(dp[2], dp[1] - prices[i])
        dp[3] = Math.max(dp[3], dp[2] + prices[i])
    }
    return dp[3]
};
```



**优化**
将Math.max换成比较运算符，用临时变量暂存运算结果，满足条件时赋值

```javascript
var maxProfit14 = function(prices) {
    const dp = new Int32Array(4)
    dp[0] = dp[2] = -prices[0]
    for (let i = 1, t; i < prices.length; i++) {
        if ((t = -prices[i]) > dp[0]) dp[0] = t
        if ((t = dp[0] + prices[i]) > dp[1]) dp[1] = t
        if ((t = dp[1] - prices[i]) > dp[2]) dp[2] = t
        if ((t = dp[2] + prices[i]) > dp[3]) dp[3] = t
    }
    return dp[3]
};
```




3.2 状态机
用s0 s1 s2 s3分别代替数组的4个元素

```javascript
var maxProfit = function(prices) {
    let s0 = s2 = -prices[0], s1 = s3 = 0
    for (let i = 1; i < prices.length; i++) {
        s0 = Math.max(s0,    - prices[i])
        s1 = Math.max(s1, s0 + prices[i])
        s2 = Math.max(s2, s1 - prices[i])
        s3 = Math.max(s3, s2 + prices[i])
    }
    return s3
};
```

**条件**
第1次交易完成前，第2次交易不会发生。当第1次交易完成后，即s1 !== 0，再计算s2 s3

```javascript
var maxProfit = function(prices) {
    let s0 = s2 = -prices[0], s1 = s3 = 0
    for (let i = 1, t; i < prices.length; i++) {
        s0 = Math.max(s0,    - prices[i])
        s1 = Math.max(s1, s0 + prices[i])
        if (s1 === 0) continue
        s2 = Math.max(s2, s1 - prices[i])
        s3 = Math.max(s3, s2 + prices[i])
    }
    return s3 || s1 // 在第1次交易完成前，s3为0。若第2次交易未完成，返回s1
};  
```



###### 3.3 计数

同上，dp[j]表示第j / 2取整次交易。j为奇数，交易前，j为偶数，交易后
遍历prices，指针i表示第i天。枚举每天处于[0, j]交易状态时的利润，点击看大图

![image.png](https://gitee.com/vr2/images/raw/master/images/1610174593-qDiAJd-image.png)

```javascript
var maxProfit = function(prices) {
    const dp = new Int32Array(4).fill(-prices[0])
    for (let i = 0; i < prices.length; i++) 
        for (let j = 4; j--;) // dp只与j的最大值和奇偶性有关，顺序和倒序遍历都可以
            dp[j] = Math.max(dp[j], (dp[j - 1] || 0) + (j & 1 ? prices[i] : -prices[i]))
    return Math.max(0, ...dp) 
};
```

**优化**
第0天只能处于第1次交易前。第1天最多处于第1次交易后
第2天最多处于第2次交易前。第3天最多处于第2次交易后

所以，当i < 3时，不用枚举[0, 4]，枚举[0, i]即可
交易后无股票利润 > 交易前有股票利润：只关注j为奇数的最大值

```javascript
var maxProfit = function(prices) {
    const dp = new Int32Array(4)
    dp[0] = dp[2] = -prices[0]
    for (let i = 0; i < prices.length; i++) 
        for (let j = i < 3 ? i + 1 : 4; j--;) 
            dp[j] = Math.max(dp[j], (dp[j - 1] || 0) + (j & 1 ? prices[i] : -prices[i]))
    return dp[1] > dp[3] ? dp[1] : dp[3]
};
```



#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

 

**示例 1:**

```
输入: [1,2,3,1]
输出: true
```

**示例 2:**

```
输入: [1,2,3,4]
输出: false
```

**示例 3:**

```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```



##### 题解1:Using `Set`

```javascript
var containsDuplicate = function(nums) {
    return new Set(nums).size < nums.length;
};
```

##### 题解2:sort

We can also use `sort` which is slower O(n log n) time but improved O(1) space (although we mutate the input):

```javascript
var containsDuplicate = function(nums) {
    return nums.sort().some((a, i) => a === nums[i - 1]);
}
```

##### 题解3：排序

在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。

```javascript
var containsDuplicate = function(nums) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    for (let i = 0; i < n - 1; i++) {
        if (nums[i] === nums[i + 1]) {
            return true;
        }
    }
    return false;
};
```

复杂度分析

时间复杂度：`O(NlogN)`，其中 `N `为数组的长度。需要对数组进行排序。

空间复杂度：`O(logN)`，其中 `N` 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。

##### 题解4:哈希表

对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。

```javascript
var containsDuplicate = function(nums) {
    const set = new Set();
    for (const x of nums) {
        if (set.has(x)) {
            return true;
        }
        set.add(x);
    }
    return false;
};
```

**复杂度分析**

- 时间复杂度：*O*(*N*)，其中 N*N* 为数组的长度。
- 空间复杂度：*O*(*N*)，其中 N*N* 为数组的长度。



#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。 

**示例 1:**

```
输入: nums = [1,2,3,1], k = 3
输出: true
```

**示例 2:**

```
输入: nums = [1,0,1,1], k = 1
输出: true
```

**示例 3:**

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```



```javascript
var containsNearbyDuplicate = function(nums, k) {
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (i - map.get(nums[i]) <= k) {
      return true;
    }
    map.set(nums[i], i);
  }
  return false;
};
```

#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

 

**进阶：**

- 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

 

**示例 1：**

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 2：**

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 3：**

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 4：**

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```



```javascript
var missingNumber = function(nums) {
    // construct array of size n+1, to leave a spot for the missing element.
	// Assign each val to -1 so we can see which position was not filled
    // O(n)
    const res = new Array(nums.length+1).fill(-1);
	
	// "sort" the elements by assigning to the array based on val
    // O(n)
    for(const num of nums) {
        res[num] = num;
    }
    
	// the remaining -1 index is the missing value
    // O(n-1)
    return res.indexOf(-1);
};
```



#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

```javascript
var moveZeroes = function(nums) {
	var pos = 0;
  for (var i = 0; i < nums.length; i++) {
      if (nums[i] !== 0) {
          nums[pos++] = nums[i];
      }
  }
  for (i = pos; i < nums.length; i++) {
      nums[i] = 0;
	}
};
```



#### [414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数。

 

**示例 1：**

```
输入：[3, 2, 1]
输出：1
解释：第三大的数是 1 。
```

**示例 2：**

```
输入：[1, 2]
输出：2
解释：第三大的数不存在, 所以返回最大的数 2 。
```

**示例 3：**

```
输入：[2, 2, 3, 1]
输出：1
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**进阶：**你能设计一个时间复杂度 `O(n)` 的解决方案吗？

```javascript
var thirdMax = function(nums) {
  let first = -Infinity;
  let second = -Infinity;
  let third = -Infinity;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === first || nums[i] === second || nums[i] === third) continue;
    if (nums[i] > first) {
      [first, second, third] = [nums[i], first, second];
    } else if (nums[i] > second) {
      [second, third] = [nums[i], second];
    } else if (nums[i] > third) {
      third = nums[i];
    }
  }
  return third === -Infinity ? first : third;
};
```



#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

给定一个范围在 1 ≤ a[i] ≤ *n* ( *n* = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, *n*] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**示例:**

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```



```javascript
var findDisappearedNumbers = function(nums) {
    let res = [];
    for (let i = 0; i < nums.length; i++) {
        let num = Math.abs(nums[i]);
        let idx = num-1;
        nums[idx] = Math.abs(nums[idx]) * -1;
    }
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) res.push(i+1);
    }
    return res;
    // Time Complexity: O(N)
    // Space Complexity: O(1)
};
```



#### [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

给定一个二进制数组， 计算其中最大连续 1 的个数。

 

**示例：**

```
输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
```

 

**提示：**

- 输入的数组只包含 `0` 和 `1` 。
- 输入数组的长度是正整数，且不超过 10,000。

```javascript
var findMaxConsecutiveOnes = function(nums) {
    let max = 0, curr = 0;
    for (let k of nums) {
        max = Math.max(max, curr += k);
        if (!k) curr = 0;
    }
    return max;
};
```

Some one-liners:

```javascript
var findMaxConsecutiveOnes = function(nums) {
    return nums.join('').split('0').reduce((max, ones) => Math.max(max, ones.length), 0);
};

var findMaxConsecutiveOnes = function(nums) {
    return Math.max(...nums.join('').split('0').map(ones => ones.length));
};

var findMaxConsecutiveOnes = function(nums) {
    return Math.max(...(nums.join('').match(/1+/g) || ['']).map(ones => ones.length));
};
```

Finally a O(n²) solution if you’re looking for TLE:

```javascript
var findMaxConsecutiveOnes = function(nums) {
    let str = nums.join(''), max = nums.length + 1;
    while (!~str.indexOf('1'.repeat(--max)) && max);
    return max;
};
```



#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给你 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```



```javascript
var fib = function(N) {
    let memo = new Array(N + 1)
    memo[0] = 0
    memo[1] = 1
    for(let i = 2; i <= N; i++){
        memo[i] = memo[i - 1] + memo[i - 2]
    }
    return memo[N]
};
```

[（用js优美的写各种斐波那契数列](https://zhuanlan.zhihu.com/p/27205391)



#### [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false`。

 

**示例 1：**

```
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
```

**示例 2：**

```
输入：flowerbed = [1,0,0,0,1], n = 2
输出：false
```



```javascript
var canPlaceFlowers = function(flowerbed, n) {
    let current = 0; const size = flowerbed.length;
	for(var i = 0; i <= size; i++) {
		if (i < size && flowerbed[i] == 0) {
			current++;
			if (i == 0) current++;
			if (i == size - 1) current++;
		} else {
			n -= Math.trunc((current - 1) / 2);
			if (n <= 0) return true;
			current = 0;
		}
	}
	return false;
};
```



#### [628. 三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

给你一个整型数组 `nums` ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：6
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：24
```

**示例 3：**

```
输入：nums = [-1,-2,-3]
输出：-6
```

```javascript
var maximumProduct = function(nums) {
  let max1 = -Infinity;
  let max2 = -Infinity;
  let max3 = -Infinity;
  let min2 = Infinity;
  let min1 = Infinity;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max1) {
      [max1, max2, max3] = [nums[i], max1, max2];
    } else if (nums[i] > max2) {
      [max2, max3] = [nums[i], max2];
    } else if (nums[i] > max3) {
      max3 = nums[i];
    }
    if (nums[i] < min1) {
      [min2, min1] = [min1, nums[i]];
    } else if (nums[i] < min2) {
      min2 = nums[i];
    }
  }
  return Math.max(max1 * max2 * max3, max1 * min1 * min2);
};
```



#### [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)

给你一个整型数组 `nums` ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：6
```

**示例 2：**

```
输入：nums = [1,2,3,4]
输出：24
```

**示例 3：**

```
输入：nums = [-1,-2,-3]
输出：-6
```



```javascript
var findMaxAverage = function(nums, k) {
  let sum = 0;
  for (let i = 0; i < k; i++) {
    sum += nums[i];
  }
  
  let max = sum;
  for (let i = k; i < nums.length; i++) {
    sum = sum - nums[i - k] + nums[i];
    max = Math.max(max, sum);
  }
  
  return max / k;
};
```



#### [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```



```javascript
var findLengthOfLCIS = function(nums) {
    let len = 1, maxLen = 0;
    
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] < nums[i+1]) len++;
        else len = 1;
        maxLen = Math.max(len, maxLen);
    }
    return maxLen;  
};
```

```javascript
var findLengthOfLCIS = function(nums) {
    if(nums.length < 2) return nums.length;
    let left = 0, right = 1, maxLen = 0;
    
    while(right < nums.length) {
        if(nums[right-1] >= nums[right]) left = right;
        right++;
        maxLen = Math.max(right - left, maxLen);
    }
    return maxLen    
};
```



#### [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

给定一个非空且只包含非负数的整数数组 `nums`，数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是在 `nums` 中找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。

 

**示例 1：**

```
输入：[1, 2, 2, 3, 1]
输出：2
解释：
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
```

**示例 2：**

```
输入：[1,2,2,3,1,4,2]
输出：6
```



```javascript
const findShortestSubArray = (nums) => {
    const counts = {}
    const firstIndexes = {}
    const lastIndexes = {}
    let max = 0
    for (let i = 0; i < nums.length; i++) {
        const k = nums[i]
        counts[k] = (counts[k] || 0) + 1
        max = Math.max(max, counts[k])
        if (firstIndexes[k] === undefined) {
            firstIndexes[k] = i
        }
        lastIndexes[k] = i
    }
    let res = nums.length
    for (const k in counts) {
        if (counts[k] === max) {
            res = Math.min(res, lastIndexes[k] - firstIndexes[k] + 1)
        }
    }
    return res
};
```



#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 `0` 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

 

**示例 1：**

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

 **示例 2：**

```
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```

 

**提示：**

- `cost` 的长度范围是 `[2, 1000]`。
- `cost[i]` 将会是一个整型数据，范围为 `[0, 999]` 。

````javascript
var minCostClimbingStairs = function(cost) {
    /*
    Runtime: 64 ms, faster than 100.00% of JavaScript online submissions for Min Cost Climbing Stairs.
    Memory Usage: 34.9 MB, less than 60.61% of JavaScript online submissions for Min Cost Climbing Stairs.
    
    O(n) time, O(1) space
	
	- Bottom up strategy
	- Iterative
	- Memoization
	
	Trick: At index [i], you only need to know the min cost when stepping on [i - 1] and [i - 2]. This is a slight variation on fibonacci.
    */
    
    if (cost.length === 1) return 0;
    if (cost.length === 2) return Math.min(cost[0], cost[1]);
    
    let minCostTwoBefore = cost[0];
    let minCostOneBefore = cost[1];
    
    for (let n = 2; n < cost.length; n++) {
        const minCostAtCurrent = cost[n] + Math.min(minCostOneBefore, minCostTwoBefore);
        
        minCostTwoBefore = minCostOneBefore;
        minCostOneBefore = minCostAtCurrent;
    }
        
    return Math.min(minCostOneBefore, minCostTwoBefore);
};
````



![2DNUDt](https://gitee.com/vr2/images/raw/master/images/2DNUDt.png)

##### 题解1:动态规划

```javascript
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    const dp = new Array(n + 1);
    dp[0] = dp[1] = 0;
    for (let i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
};
```

上述代码的时间复杂度和空间复杂度都是 `O(n)`。注意到当 `i≥2` 时，`dp[i]` 只和`dp[i−1]` 与 `dp[i−2] `有关，因此可以使用滚动数组的思想，将空间复杂度优化到 `O(1)`。

```javascript
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    let prev = 0, curr = 0;
    for (let i = 2; i <= n; i++) {
        let next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);
        prev = curr;
        curr = next;
    }
    return curr;
};
```

复杂度分析

- 时间复杂度：`O(n)`，其中 nn 是数组 `cost` 的长度。需要依次计算每个 `dp` 值，每个值的计算需要常数时间，因此总时间复杂度是 `O(n)`。
- 空间复杂度：`O(1)`。使用滚动数组的思想，只需要使用有限的额外空间。

#### [867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)

给你一个二维整数数组 `matrix`， 返回 `matrix` 的 **转置矩阵** 。

矩阵的 **转置** 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

![img](https://gitee.com/vr2/images/raw/master/images/hint_transpose.png)

 

**示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
```

**示例 2：**

```
输入：matrix = [[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]
```



```javascript
var transpose = function(A) {
    return A[0].map((_,  i) => A.map(b => b[i]));
};
```

