## js的数据类型

js的数据类型分为：原始类型（即基本类型）和对象类型（即引用数据类型）

- 基本类型：
  - `Undefined`、`Null`、`Number`、`Boolean`、`String`、`Symbol`
- 引用数据类型：
  - `Object`、`Array`、`Function`、`Date`、`RegExp`等等



## 一、基本类型和引用数据类型的区别



### 基本类型

- 基本类型不能由属性

  ```javascript
  let name = 'Tom';
  name.age = 18;
  
  console.log(name.age) // undefined
  ```

  ```javascript
  // 只有引用值可以动态添加后面的属性
  let name = new Sttring('Tom')
  // name -> String {"Tom"}
  name.age = 18
  console.log(name.age) // 18
  // name -> String {"Tom", age: 19}
  
  typeof name // "object"
  ```

  

- 基本类型的值是不变的

  ```javascript
  let name = 'tom'
  name.toUpperCase() // "TOM"
  name // tom
  ```

- 基本类型是按值传递

  ```javascript
  let name = 'tom';
  let name2 = 'TOM';
  name = name2;
  console.log(name, name2) // TOM TOM
  ```

- 基本类型的比较是比较它们的值

  ```javascript
  let a = 1;
  let b = true;
  
  a == b // true
  a === b // false
  ```

- 基本类型的变量是存放在`stack`(栈)

  ```javascript
  let a = 'tom';
  let b = 123;
  ```

![rskRFk](https://gitee.com/vr2/images/raw/master/uPic/rskRFk.png)

### 引用类型

- 引用类型的值是可变

  ```javascript
  const obj = {
    name: 'tom',
    age: 18
  }
  obj.sex = 'man';
  obj.getName = function () {
    console.log(this.name)
  }
  ```

- 引用类型的比较是引用的比较

  ```javascript
  const o1 = {};
  const o2 = {};
  
  o1 === o2 // false
  o1 == o2 // false
  ```

  `o1` 、`o2` 引用分别放在堆内存中的2个对象

- 引用是类型的值是保存在堆内存中，指针存在栈中。

  ![image-20201203203052622](/Users/hello/Library/Application Support/typora-user-images/image-20201203203052622.png)



#### 一道题实战

```javascript
function addNum (num) {
    num += 1;
    return num
}

let count = 10;

let result = addNum(count);

console.log(count); // 10
console.log(result) // 11


function setPhone (obj) {
    obj.phone = '123'
}

let p1 = new Object();
setPhone(p1)
console.log(p1) // {phone: '123'}


function setPhone (obj) {
    obj.phone = '123'
    // 创建一个新的对象
    obj = new Object();
    obj.phone = '456'
}

let p1 = new Object();
setPhone(p1)

console.log(p1) // {phone: '123'}
```



## 二、类型检测

- `typeof`
  - 只能检测基本数据类型 但是typeof null 是"object"，不能检测复杂类型 
- `instanceof` 通过原型链去查找的
  - 返回的是false 或者true
  - 可以识别内置对象类型、自定义类型及其父类型
  - 不能识别标准类型，会返回false
  - 不能识别undefined、null，会报错
- `constructor`属性 实例对象的constructor属性指向其构造函数。如果是内置类型，则输出`function` 数据类型`(){[native code]}`；如果是自定义类型，则输出`function` 数据类型`(){}`
  - 可以识别标准类型、内置对象类型及自定义类型
  - 不能识别`undefined`、`nul`，会报错，因为它俩没有构造函数
- `Object.prototype.toString()` 返回` [object 数据类型]`
  - 可以识别标准类型及内置对象类型
  -  不能识别自定义类型
- `Array.isArray()`  数组的检测



### typeof

`typeof`只能判断基本数据类型，不能判断引用数据类型（返回 `object`）

```javascript
let s = 'tom';
let num = 123;
let bool = true;
let sy = Symbol('tom')
let u;
let n = null;
let o = new Object();


typeof s    // string
typeof num  // number
typeof bool // boolean
typeof u    // undefined
typeof sy   // symbol

typeof n    // object
typeof o    // object
```

**注意**：`typeof null `为`object` 

###### 为什么`typeof null `为`object` ？

在 JavaScript 中 `typeof null` 的结果为 `"object"`，这是从 JavaScript 的第一版遗留至今的一个 bug。在第一版的 JavaScript 中，变量的值被设计保存在一个 32 位的内存单元中。该单元包含一个 1 或 3 位的类型标志，和实际数据的值。类型标志存储在单元的最后。

| 数据类型     | **机器码标识** |
| ------------ | -------------- |
| 整数         | 1              |
| 浮点数       | 010            |
| 字符串       | 100            |
| 布尔         | 110            |
| undefined    | -2^31(即全为1) |
| null         | 全为0          |
| 对象(Object) | 000            |

在判断数据类型时，是根据机器码低位标识来判断的，而`null`的机器码标识为全`0`，而对象的机器码低位标识为`000`。所以`typeof null`的结果被误判为`Object`。



### instanceof

- 通过原型链去查找的
- 返回的是false 或者true
- 可以识别内置对象类型、自定义类型及其父类型
- 不能识别标准类型，会返回false
- 不能识别undefined、null，会报错

```javascript
'a' instanceof String -> false
12 instanceof Number -> false
true instanceof Boolean -> false
undefined instanceof Undefined  ->报错
[] instanceof Array -> true
new Person instanceof Person -> true
new Person instanceof Object -> true
```



### constructor

`constructor`属性 实例对象的constructor属性指向其构造函数。如果是内置类型，则输出`function` 数据类型`(){[native code]}`；如果是自定义类型，则输出`function` 数据类型`(){}`

- 可以识别标准类型、内置对象类型及自定义类型
-  不能识别`undefined`、`nul`，会报错，因为它俩没有构造函数

```javascript
('a').constructor -> function String(){[native code]}
(undefined).constructor) -> 报错
null).constructor -> 报错
{name: "jerry"}).constructor -> function Object(){[native code]}
(new Person).constructor -> function Person(){}
// 封装成一个类型识别函数
function type(obj){
  var temp = obj.constructor.toString();
  return temp.replace(/^function (\w+)\(\).+$/,'$1');
}
```

​	

### Object.prototype.toString()

`Object.prototype.toString()` 返回` [object 数据类型]`

- 可以识别标准类型及内置对象类型
-  不能识别自定义类型

```javascript
Object.prototype.toString.call('a') -> [object String]
Object.prototype.toString.call(undefined) -> [object Undefined]
Object.prototype.toString.call(null) -> Null
Object.prototype.toString.call({name: "jerry"})) ->object Object]
Object.prototype.toString.call(function(){}) -> [object Function]
Object.prototype.toString.call(new Person)) -> [object Object]
```

封装成一个类型识别函数

```javascript
 function type(obj){
   return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase();
 }
```



### Array.isArray()

​	数组检测

```javascript
const a = [1,2,3]
Array.isArray(a) -> true
Array.isArray([]) -> true
```



