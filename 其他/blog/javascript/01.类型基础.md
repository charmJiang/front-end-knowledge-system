### 1.类型基础

#### 1.1.js内置类型

![](https://gitee.com/vr2/images/raw/master/img/231452.png)



- `JS` 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（`Object`）。
- 基本类型有七种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`, `bigint`。(js最大安全数是 **Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1, 而不是Math.pow(2,52) - 1**)
- 一种引用数据类型——`Object`（Object本质上是由一组无序的名值对组成的）。里面包含 `function、Array、Date`等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。
  - **引用数据类型:** 对象`Object`（包含普通对象-`Object`，数组对象-`Array`，正则对象-`RegExp`，日期对象-`Date`，数学函数-`Math`，函数对象-`Function`

> JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储：

- **原始数据类型**：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。
- **引用数据类型**：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

##### JavaScript 中的数据是如何存储在内存中的？

> 在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是`代码空间`、`栈空间`、`堆空间`。其中的代码空间主要是存储可执行代码的，原始类型(`Number、String、Null、Undefined、Boolean、Symbol、BigInt`)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在"堆空间"中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。

JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。

##### 题目1

```js
const p = {
    name: 'tom',
    age: 18
}

const p2 = p

p2.name = 'alex'

// alex
console.log(p.name)

// alex
console.log(p.name)

```

体现了引用类型的“共享”的特性，即这两个值都存在同一块内存中共享，一个发生了改变，另外一个也随之跟着变化。

##### 题目2

```js
let a = {
  name: 'Julia',
  age: 20
}
function change(o) {
  o.age = 24;
  o = {
    name: 'Kath',
    age: 30
  }
  return o;
}
let b = change(a); 
console.log(b.age);    // {name: "Kath", age: 30}
console.log(a.age);    // {name: "Julia", age: 24}
```

原因在于：函数传参进来的 `o`，传递的是对象在堆中的内存地址值，通过调用 `o.age = 24`（第 7 行代码）确实改变了 `a` 对象的 `age` 属性；但是第 12 行代码的 `return` 却又把 `o` 变成了另一个内存地址，将 `{name: "Kath", age: 30}` 存入其中，最后返回 `b` 的值就变成了 `{name: "Kath", age: 30}`。而如果把第 12 行去掉，那么 `b` 就会返回 `undefined`

##### 题目3

```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// --> undefined
b.x 	// --> {n: 2}
```

- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。
- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`

![img](http://resource.muyiy.cn/image/2019-07-24-060217.png)

#### 1.2 .什么是bignit

`BigInt`是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

**为什么需要BigInt?**

在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？

> 这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的`Number`类型只能安全地表示`-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)）`，任何超出此范围的整数值都可能失去精度。

```text
console.log(999999999999999);  //=>10000000000000000 
```

同时也会有一定的安全性问题:

```text
9007199254740992 === 9007199254740993;    // → true 居然是true! 
```

**如何创建并使用BigInt？**

要创建`BigInt`，只需要在数字末尾追加`n`即可

```text
console.log( 9007199254740995n );    // → 9007199254740995n	
console.log( 9007199254740995 );     // → 9007199254740996 
```

另一种创建`BigInt`的方法是用`BigInt()`构造函数

```text
BigInt("9007199254740995");    // → 9007199254740995n 
```

简单使用如下:

```text
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
+10n;         // → TypeError: Cannot convert a BigInt value to a number	
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
console.log(typeof x);   //"bigint" 
```

**值得警惕的点**

> `BigInt`不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 `Number` 的不变量，或者抛出异常。另外，更改 `+` 的行为也会破坏 `asm.js` 代码。

因为隐式类型转换可能丢失信息，所以不允许在`bigint`和 `Number` 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由`BigInt`或`Number`精确表示。

```text
10 + 10n;    // → TypeError 
```

> 不能将`BigInt`传递给`Web api`和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。

```text
Math.max(2n, 4n, 6n);    // → TypeError 
```

> 当 `Boolean` 类型与 `BigInt` 类型相遇时，`BigInt` 的处理方式与`Number`类似，换句话说，只要不是`0n`，`BigInt`就被视为`truthy`的值。

```text
if(0n){//条件判断为false

}
if(3n){//条件为true

} 
```

- 元素都为BigInt的数组可以进行sort。
- `BigInt`可以正常地进行位运算，如`|`、`&`、`<<`、`>>`和`^`

**浏览器兼容性**

caniuse的结果:

![](https://gitee.com/vr2/images/raw/master/112222.png)

其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现，要正式成为规范，其实还有很长的路要走

#### 1.3.null和undefined的区别

- `null` 和`undefined`都是基础数据类型

- typeof null --> 'object'

- typeof undefined --> 'undefined' 

  **undefined**

`Undefined`类型只有一个值，即`undefined`。当声明的变量还未被初始化时，变量的默认值为`undefined`。

- 变量被声明了，但没有赋值时，就等于`undefined`。
- 调用函数时，应该提供的参数没有提供，该参数等于`undefined`。
- 对象没有赋值的属性，该属性的值为`undefined`。
- 函数没有返回值时，默认返回`undefined`

 **null**

`Null`类型也只有一个值，即`null`。`null`用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。

- 作为函数的参数，表示该函数的参数不是对象。
- 作为对象原型链的终点



#### 1.4.为什么typeof null 为 'object'? null是对象吗？

`null`不是对象。虽然 `typeof null` 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。



#### 1.5. 01 + 0.2 != 0.3?

计算机无法直接对十进制的数字进行运算，这是硬件物理特性已经决定的。这样运算就分成了两个部分：**先按照IEEE 754转成相应的二进制，然后对阶运算**

##### 1.5.1进制转换

0.1和0.2转换成二进制后会无限循环

```js
0.1 -> 0.0001100110011001...(无限循环)
0.2 -> 0.0011001100110011...(无限循环)
```

但是由于IEEE 754尾数位数限制，需要将后面多余的位截掉,这样在进制之间的转换中精度已经损失。

##### 1.5.2 对阶运算

由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损，按照上面两步运算（包括两步的精度损失），最后的结果是

```js
0.0100110011001100110011001100110011001100110011001100 
```

结果转换成十进制之后就是0.30000000000000004，这样就有了：0.1 + 0.2 != 0.3

##### 1.5.3 结论

- 0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成`0.30000000000000004`

- **精度损失可能出现在进制转化和对阶运算过程中**
- **精度损失可能出现在进制转化和对阶运算过程中**
- **精度损失可能出现在进制转化和对阶运算过程中**

##### 1.5.4 怎么解决精度问题？

- 将数字转成整数

  ```js
  function add(num1, num2) {
   const num1Digits = (num1.toString().split('.')[1] || '').length;
   const num2Digits = (num2.toString().split('.')[1] || '').length;
   const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
   return (num1 * baseNum + num2 * baseNum) / baseNum;
  }
  ```

- 第三方库 `Math.js`, `big.js`...